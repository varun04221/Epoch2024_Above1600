# -*- coding: utf-8 -*-
"""Epoch.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1LXu-xqzJuaZ1n4PfqSN6EL9DECaselI0

#Problem Statement 4: Efficient and fair line construction

Importing required libraries and functions for data visualization and computation.
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.linear_model import LinearRegression
from sklearn.datasets import fetch_california_housing
from sklearn.cluster import AgglomerativeClustering
import math

"""Importing dataset and previewing it."""

data=fetch_california_housing(as_frame=True)

data=data.frame

lat=np.array(data['Latitude'])
lon=np.array(data['Longitude'])

data

"""Applying classical Linear Regression and Analysing its cost effective-ness."""

from sklearn.linear_model import LinearRegression
regr=LinearRegression()
regr.fit(lat.reshape(-1,1),lon.reshape(-1,1))
lon_pred=regr.predict(lat.reshape(-1,1))

"""predicting the line with simple regression here line(K) =1"""

fig,axs=plt.subplots(1,figsize=(30,20))
axs.scatter(lat,lon,marker='+')
axs.plot(lat,lon_pred,color='red')

"""calculate_I_AP -it returns the value of (I-a.aT).(p-b)

norm- It finds the norm of the final resulting vector calculate_I_AP uses this norm function

all_lines-It returns the all possible traslation on map

getting_b-on a line we want to get all possible points for axis of rotation
get rotation-rotates the line about a particular b

Then the print is denoting all possible orientation of line in a 3 d matrix
"""

def calculate_I_AP(a, p,b):
    x=np.transpose(a)
    A = np.multiply(a, x)
    I = np.eye(2)
    result = np.dot(I,p-b) - np.dot(A, p-b)
    return np.square(norm(result))


def norm(x):
  return np.linalg.norm(x)

def all_lines(slat,elat,slon,elon):
    lis=[];i=slat
    while i<elat+0.1:
        cur=[]
        j=slon
        while j<elon+0.1:
            cur.append((i,j))
            j+=0.5
        lis.append(np.array(cur))
        i+=0.5
    return np.array(lis)
#array containing values of tan(x) for x=0 degree, 10 degree......180 degree.
i_cap = np.array([0.0, 0.17632698070846498, 0.36397023426620234, 0.5773502691896257, 0.8390996311772799, 1.19175359259421, 1.7320508075688767, 2.7474774194546216, 5.671281819617707, 1.633123935319537e+16, -5.671281819617711, -2.7474774194546243, -1.7320508075688783, -1.19175359259421, -0.8390996311772804, -0.5773502691896263, -0.36397023426620256, -0.1763269807084649])


def get_rotation(point_x, point_y):
    l = []
    for i in i_cap:
        l.append(np.array([point_x,point_y]))
    return np.array(l)

def getting_b(points):

  x = points.shape[0]
  y = points.shape[0]

  result = []
  for i in range(x):
    temp2 = []
    for point in points[i]:
      temp = get_rotation(point[0], point[1])
      temp2.append(temp)
    result.append(np.array(temp2))

  return np.array(result)

ever=all_lines(min(lat),max(lat),min(lon),max(lon))
rotated=getting_b(ever)
print(rotated)
rotated.shape

"""Getting the values of all answers for lattitude,longitude we just need a point r and theta angle of rotation for that point  that point is nothing but b  which in turn is r so all the function written above will be used and we will get final value of answer in our self written regression code and this change all the 3 parameters at very slow rate so this code requires approx 96 minute runtime (approx) to see output of this function uncomment this line
      # calculated=final(min(lat),max(lat),min(lon),max(lon))
and the next cell.
"""

def final(strtlat,endlat,strtlon,endlon):
    final_ans=[]
    curlat=strtlat
    while curlat<endlat+0.1:
        this_line=[]
        curlon=strtlon
        while curlon<endlon+0.1:
            this_point=[]
            for i in range(0,181,5):
                this_orn=0
                for p in range(len(lat)):
                    point=np.array([lat[p],lon[p]])
                    b=np.array([curlat,curlon])
                    a=np.array([1,math.tan(i*(math.pi)/180)])
                    this_orn+=calculate_I_AP(a,point,b)
                this_point.append(this_orn)
            this_line.append(np.array(this_point))
            curlon+=0.5
        final_ans.append(np.array(this_line))
        curlat+=0.5
    return np.array(final_ans)

#calculated=final(min(lat),max(lat),min(lon),max(lon))

"""The final function returns out us a matrix for each line but for final(final ans) we need minimum of each such line  this cell simply tells us the latitude longitude and rotation that is r and theta for plotting our model line"""

# print(calculated)
# shape=calculated.shape
# shape

# this=1e9
# ans=[]

# for i in range(20):
#     for j in range(21):
#         for k in range(19):
#             if calculated[i][j][k]<this:
#                 this=calculated[i][j][k]
#                 ans=[i,j,k]

# print(this)
# print(ans)

lat

"""# Objective 1:Efficient Line

Calculating efficient line by translation of the line across latitudes and longitudes and rotation along various points.

And plotting the line.


Due to large time we have to change our deltas to a larger value (learning rate of model) now due to larger learning rate we need 5 minutes
"""

def final(strtlat,endlat,strtlon,endlon):
    final_ans=[]
    curlat=strtlat
    while curlat<endlat+0.1:
        this_line=[]
        curlon=strtlon
        while curlon<endlon+0.1:
            this_point=[]
            for i in range(0,181,15):
                this_orn=0
                for p in range(len(lat)):
                    point=np.array([lat[p],lon[p]])
                    b=np.array([curlat,curlon])
                    a=np.array([1,math.tan(i*(math.pi)/180)])
                    this_orn+=calculate_I_AP(a,point,b)
                this_point.append(this_orn)
            this_line.append(np.array(this_point))
            curlon+=1.5
        final_ans.append(np.array(this_line))
        curlat+=1.5
    return np.array(final_ans)

calculated=final(min(lat),max(lat),min(lon),max(lon))

"""This is just getiing the latitude longitude and theta for that larger learning rate function for plotting line"""

calculated

starters=np.array([min(lat),min(lon),0])
tba=[]
val=1e18
for i in range(calculated.shape[0]):
    for j in range(calculated.shape[1]):
        for k in range(calculated.shape[2]):
            if calculated[i][j][k]<val:
                val=calculated[i][j][k]
                tba=[1.5*i,1.5*j,k*15]
tba=np.array(tba)
starters=starters+tba
print("Minimum Cost:",val)
print("Point b(latitude, longitude):",(starters[0],starters[1]))
print("Angle made by the direction vector with the latitude axis:",starters[2],"Degrees.")

"""getting calculation for line equation"""

x_axis=np.linspace(min(lat),max(lat),10)
slope=math.tan(tba[2]*math.pi/180)
x=starters[0]
y=[starters[1]+(i-x)*slope for i in x_axis]
y=np.array(y)

"""Plotting the graphs"""

fig,axs=plt.subplots(1,figsize=(30,20))
axs.scatter(lat,lon,marker='+')
axs.plot(x_axis,y,color='red')

"""#Objective 2:Finding a Fair Line

Caculating fair line by minimizing the objective function over various lines and rotation of line along various points.

And plotting the line.
"""

def sec_final(strtlat,endlat,strtlon,endlon):
    final_ans=[]
    curlat=strtlat
    while curlat<endlat+0.1:
        this_line=[]
        curlon=strtlon
        while curlon<endlon+0.1:
            this_point=[]
            for i in range(0,181,15):
                this_orn=0
                for p in range(len(lat)):
                    point=np.array([lat[p],lon[p]])
                    b=np.array([curlat,curlon])
                    a=np.array([1,math.tan(i*(math.pi)/180)])
                    this_orn=max(this_orn,calculate_I_AP(a,point,b))
                this_point.append(this_orn)
            this_line.append(np.array(this_point))
            curlon+=1.5
        final_ans.append(np.array(this_line))
        curlat+=1.5
    return np.array(final_ans)

calculated=sec_final(min(lat),max(lat),min(lon),max(lon))

"""getting appropriate value of lat,lon and theta for the function and then plotting the line for ojective 2"""

starters=np.array([min(lat),min(lon),0])
tba=[]
val=1e18
for i in range(calculated.shape[0]):
    for j in range(calculated.shape[1]):
        for k in range(calculated.shape[2]):
            if calculated[i][j][k]<val:
                val=calculated[i][j][k]
                tba=[1.5*i,1.5*j,k*15]
tba=np.array(tba)
starters=starters+tba
print("Minimum Cost:",val)
print("Point b(latitude, longitude):",(starters[0],starters[1]))
print("Angle made by the direction vector with the latitude axis:",starters[2],"Degrees.")


x_axis=np.linspace(min(lat),max(lat),10)
slope=math.tan(tba[2]*math.pi/180)
print(slope)
x=starters[0]
y=[starters[1]+(i-x)*slope for i in x_axis]
y=np.array(y)

fig,axs=plt.subplots(1,figsize=(30,20))
axs.scatter(lat,lon,marker='+')
axs.plot(x_axis,y,color='red')

"""#Objective 3: Multiple Efficient Lines

Finding multiple efficient lines is done by first clustering the datapoints into k clusters based on their distance metric (for the same we have used AgglomerativeClustering algorithm provided by the sklearn which effectively cluster data points based on distance) and then dealing with each cluster independently i.e applying the process identical to objective-1 on each cluster independently. This drastically reduces the cost.

inputting integers and AgglomerativeClustering (clustering algo we studied which ismade from k means clustering but keeping in mind for distance metric) this would be highly useful for our goal as we have to minimize distance.
"""

k_=int(input("Enter the value of K:"))
let=np.column_stack((lat,lon))

clustering=AgglomerativeClustering(n_clusters=k)
clustering.fit(let)

labels=clustering.labels_

"""The third_final code is written in such a way for each cluster we made a cylendrical pipeline which return a point that has (lat,lon) and a theta for each k clusters"""

def third_final(strtlat,endlat,strtlon,endlon):
    final_ans=[]
    beglat=strtlat
    while beglat<endlat+0.1:
        this_line=[]
        beglon=strtlon
        while beglon<endlon+0.1:
            this_point=[]
            for i in range(0,181,15):
                this_orn=0
                for p in range(len(curlat)):
                    point=np.array([curlat[p],curlon[p]])
                    b=np.array([beglat,beglon])
                    a=np.array([1,math.tan(i*(math.pi)/180)])
                    this_orn+=calculate_I_AP(a,point,b)
                this_point.append(this_orn)
            this_line.append(np.array(this_point))
            beglon+=1.5
        final_ans.append(np.array(this_line))
        beglat+=1.5
    return np.array(final_ans)

"""This is for getting minimum value for each clusters and then getting equation of line for each clusters and plotting the line in each clusters

"""

fig,axs=plt.subplots(1,figsize=(30,20))
axs.scatter(lat,lon,c=labels,cmap='viridis',marker='+')

minimum_cost=[]
points=[]
degree=[]

for i in range(k_):
    curlat=np.array(lat[labels==i]);curlon=np.array(lon[labels==i])
    calculated=third_final(min(curlat),max(curlat),min(curlon),max(curlon))

    starters=np.array([min(curlat),min(curlon),0])
    tba=[]
    val=1e18
    for i in range(calculated.shape[0]):
        for j in range(calculated.shape[1]):
            for k in range(calculated.shape[2]):
                if calculated[i][j][k]<val:
                    val=calculated[i][j][k]
                    tba=[1.5*i,1.5*j,k*15]
    tba=np.array(tba)
    starters=starters+tba
    minimum_cost.append(val)
    points.append((starters[0],starters[1]))
    degree.append(starters[2])

    x_axis=np.linspace(min(curlat),max(curlat),10)
    slope=math.tan(tba[2]*math.pi/180)
    print(slope)
    x=starters[0]
    y=[starters[1]+(i-x)*slope for i in x_axis]
    y=np.array(y)
    print("x=",x)
    print("y=",y)
    axs.plot(x_axis,y,color='red')

print("Point b for each cluster (latitude,longitude):",points)
print("Angle with latitude axis made by line:",degree)
print("Cost for each cluster:",minimum_cost)
print("Total cost for all clusters:",sum(minimum_cost))